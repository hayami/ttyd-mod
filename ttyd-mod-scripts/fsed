#!/bin/sh
set -e

TMPDIR=${TMPDIR:-/tmp}
export TMPDIR

perl=${perl:-perl}
if $perl -v 2>&1 | grep --quiet "^This is perl 5,"; then
    :
else
    echo "ERROR: perl5 is required" 1>&2
    exit 1
fi


_fsed() (
    orig="$1"
    new="$2"
    target="$3"
    outfile="$4"
    [ -n "$outfile" ] || outfile="$target"
    tmpout="$TMPDIR/$$.out"

    if ! grep -F --quiet -e "$orig" "$target"; then

        if ! grep -F --quiet -e "$new" "$target"; then
            echo "ERROR: The string to be replaced was not found: $target" 1>&2
            return 1
        else
            (
            echo "WARNING: The string to be replaced was not found in the target file, but"
            echo "  it contains the string after substitution. The target file may already"
            echo "  be substituted: $target"
            ) 1>&2
            return 2
        fi
    fi

    # - \Q...\E は、中身を全部エスケープして固定文字列として扱う
    #
    # - perl -pe '...' は 内部的に readline (<>) を使ったループに
    #   なるため、行末尾の改行文字はその有無を含めて保持される
    #
    env orig="$orig" new="$new" $perl -pe 's/\Q$ENV{orig}\E/$ENV{new}/g' < "$target" > "$tmpout"

    # ファイルのサイズから 1 回だけ置換されていることを検査する
    # (但し、置換前後の文字列長が同じ場合は検出できない)
    #
    origstrlen=$(printf '%s' "$orig" | wc -c)
    newstrlen=$(printf '%s' "$new" | wc -c)
    targetfsize=$(wc -c < "$target")
    tmpoutfsize=$(wc -c < "$tmpout")
    if [ $(($targetfsize - $origstrlen + $newstrlen)) -ne $tmpoutfsize ]; then
        echo "ERROR: Substitution may occur multiple times" 1>&2
        rm -f "$tmpout"
        return 1
    fi

    cat "$tmpout" > "$outfile"
    rm -f "$tmpout"
    return 0
)


ret=0
_fsed "$@" || ret=$?
exit $ret
